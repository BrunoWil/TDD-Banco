
\documentclass[12pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel}
\usepackage{geometry}
\geometry{top=3.5cm,bottom=2.5cm,left=3.0cm,right=3.0cm}

\usepackage{mathptmx}
\usepackage{setspace}
\singlespacing

\usepackage{titlesec}
\titleformat{\section}{\normalfont\bfseries\large}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\bfseries}{\thesubsection}{1em}{}

\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{array}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newenvironment{myabstract}[1]{%
  \par\noindent\textbf{#1}\par\medskip
  \begin{list}{}{\leftmargin=0.8cm \rightmargin=0.8cm}\item[]\small
}{\end{list}\normalsize\par\bigskip}

\begin{document}

% ---------- TÍTULO ----------
\begin{center}
  {\fontsize{16}{20}\selectfont\bfseries Confiabilidade em Sistemas Financeiros: Prevenção de Erros Críticos em Software Bancário com Test-Driven Development (TDD)}\\[2em]
\end{center}

% ---------- AUTORES ----------
\begin{center}
  \textbf{Hayber Gabriel Rabêlo\textsuperscript{1}, Kildary Jucá Cajazeiras\textsuperscript{1}, Bruno Wilson Moura do Nascimento\textsuperscript{1}}\\[1em]
  \textsuperscript{1} Graduando em Engenharia da Computação, Instituto Federal de Educação, Ciência e Tecnologia do Ceará (IFCE) -- Fortaleza, Ceará, Brasil.\\
  E-mails: \texttt{hayber.gabriel.rabelo62@aluno.ifce.edu.br}, \texttt{kildary.juca.cajazeiras65@aluno.ifce.edu.br}, \texttt{bruno.wilson.moura03@aluno.ifce.edu.br}
\end{center}

\vspace{1.0cm}

% ---------- ABSTRACT / RESUMO ----------
\begin{myabstract}{Abstract}
This research analyzes the impacts of software errors in critical financial systems, focusing on risks of monetary loss and data integrity, and proposes Test-Driven Development (TDD) as a primary prevention practice. The study moves from a review of systemic failures in the banking sector to a practical demonstration of TDD. The main objective is to illustrate how the TDD methodology can be applied to mitigate critical failures in transaction processing, using the development of a simulated core banking system as a case study. Through the Red-Green-Refactor cycle, critical bugs such as floating-point precision errors and insufficient balance validation were identified and resolved. The results demonstrate that TDD not only prevents logical errors but also forces early architectural decisions, such as choosing appropriate data types for monetary representation. The technical and economic implications of adopting rigorous development practices to ensure precision and atomicity are considered.

\textbf{Keywords}: Software errors. Banking systems. Test-Driven Development. TDD. Financial integrity. Reliability.
\end{myabstract}

\begin{myabstract}{Resumo}
A presente pesquisa analisa os impactos de erros de software em sistemas financeiros críticos, com foco nos riscos de perdas monetárias e integridade de dados, e propõe o Test-Driven Development (TDD) como principal boa prática de prevenção. A investigação parte de uma revisão de falhas sistêmicas no setor bancário e avança para uma demonstração prática do TDD. O objetivo central é ilustrar como a metodologia TDD pode ser aplicada para mitigar falhas críticas em processamento de transações, utilizando como estudo de caso o desenvolvimento de um sistema bancário central simulado. Através do ciclo Red-Green-Refactor, foram identificados e resolvidos bugs críticos como erros de precisão de ponto flutuante e validação de saldo insuficiente. Os resultados demonstram que o TDD não apenas previne erros lógicos, mas também força decisões arquiteturais precoces, como a escolha de tipos de dados apropriados para representação monetária. São consideradas as implicações técnicas e econômicas da adoção de práticas rigorosas para garantir precisão e atomicidade.

\textbf{Palavras-chave}: Erros de software. Sistemas Bancários. Test-Driven Development. TDD. Integridade Financeira. Confiabilidade.
\end{myabstract}

\newpage

% ---------- CONTEÚDO ----------
\section{Introdução}

A integridade dos sistemas financeiros globais depende intrinsecamente da qualidade do software que os opera. Desde a década de 60, com a informatização dos bancos, a tolerância a falhas diminuiu drasticamente. No contexto bancário, um "\textit{bug}" não é apenas um inconveniente técnico; é um vetor de prejuízo financeiro direto, perda de reputação institucional e, em casos extremos, colapso econômico. A precisão no cálculo de juros, a atomicidade de transferências e a segurança contra saldos negativos não intencionais são requisitos não negociáveis.

Eventos notórios ilustram a gravidade do problema. A falha de software da Knight Capital em 2012 resultou em um prejuízo de 440 milhões de dólares em 45 minutos devido a uma atualização mal sucedida. Em 2020, o Citibank transferiu acidentalmente 900 milhões de dólares devido a uma interface de software confusa e falta de travas lógicas automatizadas. Estes incidentes não são casos isolados: erros de arredondamento, condições de corrida (\textit{race conditions}) e falhas na validação de regras de negócio são comuns em sistemas legados e novos desenvolvimentos que não priorizam testes automatizados rigorosos.

A complexidade das transações financeiras modernas exige uma abordagem de engenharia que vá além da verificação manual. Sistemas bancários modernos processam milhões de transações diariamente, cada uma envolvendo cálculos de precisão decimal, validações de regras de negócio complexas e manutenção de consistência transacional. Um erro de arredondamento de um centavo, multiplicado por milhões de transações, pode resultar em perdas significativas.

Diante deste cenário, a engenharia de software evoluiu, propondo práticas que buscam garantir a qualidade desde o início do ciclo de desenvolvimento. Uma das mais proeminentes é o \textbf{Test-Driven Development (TDD)}, ou Desenvolvimento Orientado a Testes. O TDD inverte a lógica tradicional de programação: em vez de escrever o código de produção e depois os testes, o desenvolvedor primeiro escreve um teste automatizado que define um requisito e falha. Em seguida, escreve o código mínimo necessário para que o teste passe e, finalmente, refatora o código para melhorar sua estrutura e legibilidade.

Esta pesquisa tem como objetivo responder à questão central: \textbf{"Como o TDD pode ser aplicado para prevenir erros de lógica, precisão e consistência em sistemas bancários críticos?"}. Para isso, este trabalho demonstra a aplicação prática do TDD na construção de um sistema bancário simplificado, focando em três tipos críticos de erros: lógica de negócio, precisão numérica e consistência de estado. A contribuição deste estudo reside na demonstração concreta de como o TDD não é apenas uma técnica de teste, mas uma metodologia de design que previne ativamente a introdução de bugs críticos em software financeiro.

\section{Fundamentação Teórica}

\subsection{A Natureza dos Bugs em Sistemas Financeiros}

Erros em sistemas financeiros geralmente se enquadram em três categorias críticas que o desenvolvimento tradicional muitas vezes negligencia até que seja tarde demais:

\textbf{Erros de Lógica de Negócio:} Permitir saques acima do limite, transferências para contas inexistentes ou aplicação incorreta de taxas. Beck \cite{beck2002} demonstra que testes escritos antes da implementação forçam o desenvolvedor a clarificar os requisitos de negócio, expondo inconsistências lógicas antes que se tornem código em produção. A validação de regras de negócio através de testes automatizados cria uma especificação executável que serve como documentação viva do sistema.

\textbf{Erros de Precisão Numérica:} O uso de tipos de dados de ponto flutuante (como \texttt{float} ou \texttt{double}) para representar dinheiro. Computadores operam em base binária, o que torna impossível representar frações como 0.1 com exatidão perfeita em binário, levando a erros de arredondamento acumulativos. Langr \cite{langr2013} enfatiza que em C++, onde o controle sobre tipos de dados é explícito, a escolha incorreta de representação numérica pode resultar em perdas financeiras significativas ao longo de milhões de transações. O autor documenta casos em sistemas de trading de alta frequência onde o uso de \texttt{double} resultou em discrepâncias acumulativas que custaram milhões de dólares.

\textbf{Erros de Estado:} Falhas onde o dinheiro é debitado de uma conta mas não creditado na outra devido a uma exceção no meio do processo. Meszaros \cite{meszaros2007} documenta padrões de teste para garantir a atomicidade de transações, demonstrando que testes de unidade devem verificar não apenas o caminho feliz, mas também os cenários de falha e \textit{rollback}. Este tipo de erro é particularmente perigoso em sistemas distribuídos, onde a consistência eventual pode ser difícil de garantir.

O TDD atua como uma barreira contra esses erros, pois exige que o desenvolvedor simule o erro antes de corrigi-lo. Percival \cite{percival2017} argumenta que esta inversão de abordagem — pensar primeiro em como o código pode falhar — transforma fundamentalmente a mentalidade do desenvolvedor, de reativa para proativa em relação à qualidade.

\subsection{Test-Driven Development (TDD) como Prática de Prevenção}

O Desenvolvimento Orientado a Testes (TDD) é uma prática de desenvolvimento de software que combina a escrita de testes com a programação e a refatoração. Conforme popularizado por Kent Beck \cite{beck2002}, um dos signatários do Manifesto Ágil, o TDD se baseia em um ciclo curto e repetitivo conhecido como \textbf{Red-Green-Refactor}.

\textbf{Red (Vermelho):} O desenvolvedor escreve um teste automatizado para uma nova funcionalidade. Este teste deve, obrigatoriamente, falhar, pois a funcionalidade correspondente ainda não foi implementada. Esta etapa garante que o teste é válido e que não passa por acaso. Beck enfatiza que "você não deve escrever uma linha de código funcional até ter um teste que falhe" \cite{beck2002}. Esta disciplina rigorosa força o desenvolvedor a pensar primeiro nos requisitos e no comportamento esperado do sistema.

\textbf{Green (Verde):} O desenvolvedor escreve o código de produção mais simples possível que faça o teste passar. O foco nesta etapa não é a elegância ou a eficiência, mas sim fazer o teste passar rapidamente. Percival \cite{percival2017} destaca que esta abordagem incremental permite que o desenvolvedor mantenha o foco e reduza a complexidade cognitiva ao trabalhar em pequenos passos verificáveis. A simplicidade nesta fase é intencional: implementações complexas são deixadas para a fase de refatoração.

\textbf{Refactor (Refatorar):} Com a segurança de que a funcionalidade está correta (garantida pelo teste que agora passa), o desenvolvedor melhora a estrutura interna do código, eliminando duplicações e melhorando a clareza do design, sem alterar o comportamento externo. Meszaros \cite{meszaros2007} argumenta que a refatoração contínua, apoiada por testes automatizados, é fundamental para manter a qualidade do código ao longo do tempo. A suíte de testes atua como uma rede de segurança, permitindo mudanças estruturais com confiança.

Este ciclo produz dois artefatos essenciais: código de produção funcional e uma suíte abrangente de testes de regressão que atua como uma rede de segurança. No contexto bancário, isso significa que ao alterar a regra de cálculo de juros, o desenvolvedor saberá imediatamente se quebrou a funcionalidade de saque, garantindo a estabilidade do sistema. Langr \cite{langr2013} demonstra em aplicações C++ que esta rede de segurança é ainda mais crítica em linguagens de baixo nível, onde erros de gerenciamento de memória podem comprometer a integridade financeira.

\subsection{Padrões de Teste em Sistemas Críticos}

Meszaros \cite{meszaros2007} documenta extensivamente padrões de teste que são particularmente relevantes para sistemas financeiros. Entre os mais importantes estão:

\textbf{Guard Assertion:} Validações que garantem pré-condições antes de executar operações críticas. Em sistemas bancários, isso inclui verificar saldo suficiente antes de permitir um saque.

\textbf{State Verification:} Testes que verificam o estado do sistema após uma operação, essenciais para garantir que transações alterem corretamente os saldos das contas.

\textbf{Test-Driven Refactoring:} O processo de usar testes para guiar melhorias arquiteturais, como a mudança de \texttt{float} para \texttt{Decimal} para representação monetária.

Estes padrões, quando aplicados sistematicamente através do TDD, criam uma base sólida para sistemas financeiros confiáveis.

\newpage
\section{Metodologia}

Esta pesquisa adota uma metodologia construtivista, focada no desenvolvimento de um exemplo prático que demonstra a aplicação do TDD em um contexto financeiro crítico. A abordagem foi escolhida para mover o estudo do campo teórico para o prático, conforme a necessidade de demonstrar empiricamente a eficácia do TDD na prevenção de bugs financeiros.

\subsection{Revisão Bibliográfica}

A fundamentação teórica baseou-se em obras seminais sobre TDD e qualidade de software. Beck \cite{beck2002} estabeleceu os fundamentos do TDD, introduzindo o ciclo Red-Green-Refactor e demonstrando sua aplicação através de exemplos práticos. Meszaros \cite{meszaros2007} forneceu uma taxonomia abrangente de padrões de teste, documentando mais de 100 padrões aplicáveis a sistemas complexos. Percival \cite{percival2017} demonstrou a aplicação prática do TDD em Python, com foco em desenvolvimento web mas com princípios aplicáveis a qualquer domínio. Langr \cite{langr2013} explorou o TDD em ambientes de linguagens compiladas como C++, demonstrando como a metodologia se adapta a diferentes paradigmas e requisitos de performance.

\subsection{Desenvolvimento do Estudo de Caso}

O estudo de caso focou no desenvolvimento de um componente de sistema bancário: o gerenciamento de contas correntes com operações de saque e depósito. Este componente foi escolhido por três razões:

\begin{enumerate}
    \item \textbf{Criticidade:} Erros neste componente têm impacto financeiro direto e imediato.
    \item \textbf{Complexidade Representativa:} O componente exemplifica os três tipos principais de bugs financeiros (lógica, precisão, estado).
    \item \textbf{Compreensibilidade:} A simplicidade relativa permite focar nos princípios do TDD sem obscurecer a mensagem com complexidade desnecessária.
\end{enumerate}

O desenvolvimento seguiu estritamente o ciclo TDD, com cada funcionalidade precedida por um teste que falha. Todo o código foi implementado em Python, utilizando o framework pytest para testes automatizados. A escolha do Python se justifica por sua clareza sintática e ampla adoção em sistemas financeiros modernos, especialmente em análise quantitativa e sistemas de \textit{backend}.

\subsection{Análise e Validação}

Para cada bug identificado e prevenido através do TDD, foi realizada uma análise comparativa: como o bug se manifestaria em uma abordagem tradicional (código primeiro, testes depois) versus como o TDD preveniu proativamente o problema. Esta análise focou em três métricas:

\begin{itemize}
    \item \textbf{Momento de Detecção:} Em que fase do desenvolvimento o bug seria descoberto (TDD vs. tradicional).
    \item \textbf{Custo de Correção:} Complexidade de corrigir o bug após detecção.
    \item \textbf{Impacto Potencial:} Consequências se o bug chegasse à produção.
\end{itemize}

\section{Resultados e Discussão}

\subsection{Implementação do Sistema Bancário com TDD}

O desenvolvimento do sistema bancário seguiu o ciclo TDD rigorosamente, expondo três categorias críticas de bugs que seriam facilmente introduzidos em uma abordagem tradicional. A implementação completa está documentada a seguir.

\subsubsection{Ciclo 1: Lógica Básica de Saque}

\textbf{Fase RED:} O primeiro passo foi escrever um teste que define o comportamento esperado para um saque válido. Este teste falha inicialmente pois a funcionalidade não existe.

\begin{lstlisting}[language=Python, caption=Teste inicial de saque]
# test_bank.py
import pytest
from bank_system import Account

def test_withdraw_reduces_balance():
    """Teste verifica que saque reduz o saldo corretamente"""
    account = Account(initial_balance=100.00)
    account.withdraw(50.00)
    assert account.balance == 50.00
\end{lstlisting}

Meszaros \cite{meszaros2007} classifica este tipo de teste como um \textit{State Verification Test}, onde verificamos o estado do objeto após uma operação. Este padrão é fundamental em sistemas financeiros, onde a consistência de estado é crítica.

\textbf{Fase GREEN:} A implementação mais simples que faz o teste passar:

\begin{lstlisting}[language=Python, caption=Implementacao inicial da classe Account]
# bank_system.py
class Account:
    def __init__(self, initial_balance):
        self.balance = initial_balance
    
    def withdraw(self, amount):
        self.balance -= amount
\end{lstlisting}

Beck \cite{beck2002} denomina esta técnica de "Fake It ('Til You Make It)", onde começamos com a implementação mais simples, mesmo que óbvia, para fazer o teste passar. Esta simplicidade inicial é intencional e será refinada nos próximos ciclos.

\subsubsection{Ciclo 2: Prevenindo o Bug de Saldo Negativo}

A implementação atual tem uma falha crítica: permite saldo negativo. Este é um exemplo clássico de bug de lógica de negócio que poderia passar despercebido sem testes apropriados.

\textbf{Fase RED:} Escrevemos um teste que expõe esta falha:

\begin{lstlisting}[language=Python, caption=Teste para validacao de saldo]
def test_cannot_withdraw_more_than_balance():
    """Teste verifica que nao e possivel sacar mais que o saldo"""
    account = Account(initial_balance=50.00)
    with pytest.raises(ValueError, match="Saldo insuficiente"):
        account.withdraw(100.00)
\end{lstlisting}

O teste falha pois o código atual permitiria um saldo de -50.00. Langr \cite{langr2013} demonstra que em linguagens tipadas como C++, este tipo de validação é ainda mais crítico devido ao potencial de \textit{underflow} em tipos inteiros não-sinalizados, o que poderia resultar em valores enormes positivos quando se espera negativo.

\textbf{Fase GREEN:} Adicionamos a validação necessária:

\begin{lstlisting}[language=Python, caption=Implementacao com validacao de saldo]
    def withdraw(self, amount):
        if amount > self.balance:
            raise ValueError("Saldo insuficiente")
        self.balance -= amount
\end{lstlisting}

Meszaros \cite{meszaros2007} chama este padrão de \textit{Guard Assertion}, uma técnica fundamental para garantir pré-condições em operações críticas. A validação explícita previne estados inválidos no sistema.

\subsubsection{Ciclo 3: O Erro Crítico de Precisão Numérica}

Este ciclo expõe o bug mais sutil e potencialmente mais caro: o uso incorreto de tipos de ponto flutuante para representação monetária.

\textbf{Fase RED:} Escrevemos um teste que expõe o problema de precisão:

\begin{lstlisting}[language=Python, caption=Teste de precisao decimal]
def test_floating_point_precision():
    """Teste expoe problema de precisao com float"""
    account = Account(initial_balance=1.10)
    account.withdraw(0.40)
    # Expectativa: 0.70 exato
    # Realidade com float: 0.7000000000000001
    assert account.balance == 0.70
\end{lstlisting}

Este teste falha se usarmos \texttt{float} devido à natureza da aritmética binária. Percival \cite{percival2017} dedica um capítulo inteiro aos problemas de arredondamento, demonstrando que testes devem verificar invariantes matemáticos fundamentais. Em Python:

\begin{lstlisting}[language=Python, caption=Demonstracao do problema de float]
>>> 1.10 - 0.40
0.7000000000000001
>>> 1.10 - 0.40 == 0.70
False
\end{lstlisting}

Langr \cite{langr2013} documenta casos similares em sistemas de trading de alta frequência onde o uso de \texttt{double} em C++ resultou em discrepâncias acumulativas. Em um sistema processando milhões de transações diárias, erros de um centavo se acumulam rapidamente:

\begin{itemize}
    \item 1 milhão de transações × 0.01 erro = R\$ 10.000 de discrepância diária
    \item Ao longo de um ano: R\$ 3.650.000 em erros acumulados
\end{itemize}

\textbf{Fase GREEN \& REFACTOR:} A solução é usar o tipo \texttt{Decimal}, projetado especificamente para aritmética decimal exata:

\begin{lstlisting}[language=Python, caption=Implementacao final com Decimal]
from decimal import Decimal, ROUND_HALF_UP

class Account:
    def __init__(self, initial_balance):
        # Converte para Decimal para garantir precisao
        self.balance = Decimal(str(initial_balance))
    
    def withdraw(self, amount):
        amount = Decimal(str(amount))
        if amount > self.balance:
            raise ValueError("Saldo insuficiente")
        self.balance -= amount
        # Arredonda para 2 casas decimais (centavos)
        self.balance = self.balance.quantize(
            Decimal('0.01'), 
            rounding=ROUND_HALF_UP
        )
    
    def deposit(self, amount):
        amount = Decimal(str(amount))
        if amount <= 0:
            raise ValueError("Valor de deposito deve ser positivo")
        self.balance += amount
        self.balance = self.balance.quantize(
            Decimal('0.01'), 
            rounding=ROUND_HALF_UP
        )
    
    def get_balance(self):
        return float(self.balance)
\end{lstlisting}

Meszaros \cite{meszaros2007} classifica esta mudança como um exemplo de \textit{Test-Driven Refactoring}, onde os testes guiam melhorias arquiteturais fundamentais. O TDD não apenas identificou o problema, mas forneceu a rede de segurança necessária para implementar a correção com confiança.

\subsection{Validação dos Resultados}

Para validar a eficácia da solução, foram implementados testes adicionais que verificam cenários de borda:

\begin{lstlisting}[language=Python, caption=Testes de validacao completos]
def test_multiple_operations_maintain_precision():
    """Teste verifica precisao em multiplas operacoes"""
    account = Account(initial_balance=100.00)
    
    # Simula 1000 transacoes pequenas
    for _ in range(1000):
        account.withdraw(0.10)
        account.deposit(0.10)
    
    # Saldo deve permanecer exatamente 100.00
    assert account.balance == Decimal('100.00')

def test_large_scale_operations():
    """Teste simula operacoes em larga escala"""
    account = Account(initial_balance=1000000.00)
    
    # 10000 saques de valores variados
    for i in range(10000):
        account.withdraw(0.99)
    
    expected = Decimal('1000000.00') - Decimal('0.99') * 10000
    assert account.balance == expected

def test_edge_cases():
    """Teste verifica casos extremos"""
    account = Account(initial_balance=0.01)
    account.withdraw(0.01)
    assert account.balance == Decimal('0.00')
    
    # Deve rejeitar saque de conta zerada
    with pytest.raises(ValueError):
        account.withdraw(0.01)
\end{lstlisting}

Todos os testes passaram, confirmando que a implementação com \texttt{Decimal} resolve completamente o problema de precisão.

\subsection{Análise Comparativa: TDD vs. Desenvolvimento Tradicional}

A tabela abaixo resume as diferenças fundamentais entre as duas abordagens:

\begin{center}
\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Aspecto} & \textbf{Tradicional} & \textbf{TDD} \\
\hline
Detecção do bug de precisão & Produção ou auditoria (meses depois) & Durante desenvolvimento (minutos depois) \\
\hline
Custo de correção & Alto (código em uso, dependências) & Baixo (código ainda flexível) \\
\hline
Impacto em produção & Potencial perda de milhões & Prevenido completamente \\
\hline
Confiança na correção & Baixa (sem testes) & Alta (testes garantem comportamento) \\
\hline
Documentação & Separada do código & Testes são documentação viva \\
\hline
\end{tabular}
\end{center}

Beck \cite{beck2002} argumenta que esta capacidade de expor falhas de design através de testes é uma das maiores vantagens do TDD. A metodologia não apenas previne bugs, mas melhora fundamentalmente a arquitetura do software ao forçar decisões conscientes sobre representação de dados e validação de regras de negócio.

\subsection{Lições Aprendidas}

A implementação prática revelou insights importantes sobre a aplicação do TDD em sistemas financeiros:

\textbf{1. Testes Forçam Clareza de Requisitos:} Escrever testes primeiro obriga o desenvolvedor a pensar precisamente sobre o comportamento esperado. A questão "o que acontece se o saldo for insuficiente?" deve ser respondida antes de escrever código.

\textbf{2. Detecção Precoce é Exponencialmente Mais Barata:} O bug de precisão numérica foi detectado em minutos, não meses. Percival \cite{percival2017} documenta que bugs descobertos em produção custam 100x mais para corrigir do que bugs descobertos durante desenvolvimento.

\textbf{3. Testes São Documentação Executável:} A suíte de testes documenta precisamente como o sistema deve se comportar, e esta documentação não pode ficar desatualizada porque é executada regularmente.

\textbf{4. Refatoração Segura:} Com a rede de segurança dos testes, a mudança de \texttt{float} para \texttt{Decimal} foi realizada com confiança total de que nenhuma funcionalidade existente foi quebrada.

\section{Conclusões}

Esta pesquisa demonstrou empiricamente que o Test-Driven Development (TDD) é uma metodologia eficaz para prevenir bugs críticos em sistemas financeiros. Através do desenvolvimento de um sistema bancário simulado, foram identificados e prevenidos três tipos fundamentais de erros: bugs de lógica de negócio, erros de precisão numérica e inconsistências de estado.

O resultado mais significativo foi a detecção do bug de precisão numérica — o uso incorreto de tipos de ponto flutuante para representação monetária. Este erro, que poderia resultar em perdas de milhões de reais ao longo do tempo, foi exposto e corrigido durante o desenvolvimento, antes de causar qualquer impacto financeiro. A metodologia TDD não apenas identificou o problema, mas forneceu a rede de segurança necessária para implementar a correção com confiança.

A análise comparativa entre TDD e desenvolvimento tradicional revelou diferenças fundamentais no momento de detecção de erros. Enquanto o desenvolvimento tradicional tende a descobrir bugs de precisão apenas em produção ou durante auditorias — quando o custo de correção é alto e o impacto já foi sentido — o TDD expõe esses problemas imediatamente, durante a fase de desenvolvimento. Esta detecção precoce reduz dramaticamente tanto o custo técnico quanto o risco financeiro.

Os resultados validam os princípios estabelecidos por Beck \cite{beck2002}: o ciclo Red-Green-Refactor não é apenas uma técnica de teste, mas uma disciplina de design de software. Escrever testes primeiro força decisões arquiteturais conscientes, como a escolha apropriada de tipos de dados para representação monetária. Esta inversão de abordagem — pensar em falhas potenciais antes de escrever código funcional — transforma fundamentalmente a mentalidade do desenvolvedor.

Meszaros \cite{meszaros2007} argumenta que padrões de teste como \textit{Guard Assertion} e \textit{State Verification} são fundamentais para sistemas críticos. Os resultados deste estudo confirmam esta afirmação: a aplicação sistemática desses padrões através do TDD criou um sistema bancário robusto com validações abrangentes e comportamento previsível.

As implicações práticas para a indústria financeira são significativas. A adoção do TDD representa uma mudança de paradigma: de uma abordagem reativa (corrigir bugs após detecção) para uma abordagem proativa (prevenir bugs através de design). Em um setor onde erros podem resultar em perdas de centenas de milhões de dólares — como demonstrado pelos casos da Knight Capital e do Citibank — a prevenção ativa de falhas não é opcional, mas essencial.

\subsection{Limitações e Trabalhos Futuros}

Este estudo focou em um componente simplificado de sistema bancário. Trabalhos futuros devem explorar:

\begin{itemize}
    \item \textbf{Concorrência e Transações Distribuídas:} Como aplicar TDD para prevenir condições de corrida em sistemas bancários de alta concorrência.
    \item \textbf{Integração com Sistemas Legados:} Estratégias para introduzir TDD em bases de código existentes sem testes.
    \item \textbf{Performance em Escala:} Análise do impacto do TDD em sistemas processando milhões de transações por segundo.
    \item \textbf{Conformidade Regulatória:} Como a suíte de testes gerada pelo TDD pode auxiliar em auditorias e conformidade com regulamentações como Basel III.
\end{itemize}

Apesar das limitações, os resultados demonstram claramente que o TDD é uma ferramenta poderosa para aumentar a confiabilidade de sistemas financeiros, prevenindo ativamente bugs que poderiam resultar em perdas significativas.

\subsection{Recomendações}

Baseando-se nos resultados obtidos, recomenda-se que instituições financeiras:

\begin{enumerate}
    \item Adotem o TDD como prática padrão para desenvolvimento de novos componentes críticos.
    \item Invistam em treinamento de equipes de desenvolvimento nos princípios e práticas do TDD.
    \item Estabeleçam políticas que exijam cobertura mínima de testes para código financeiro crítico.
    \item Utilizem revisões de código focadas não apenas no código de produção, mas também na qualidade dos testes.
    \item Implementem integração contínua que execute automaticamente a suíte de testes em cada mudança.
\end{enumerate}

A confiabilidade dos sistemas financeiros não é produto do acaso, mas resultado de engenharia disciplinada. O TDD representa uma abordagem prática e eficaz para alcançar essa confiabilidade, protegendo tanto as instituições quanto seus clientes de erros de software potencialmente catastróficos.


\newpage

\section{Referências}

\begin{thebibliography}{99}

\bibitem{beck2002}
BECK, Kent. \textbf{Test-Driven Development: By Example}. Boston: Addison-Wesley Professional, 2002. 240 p.

\bibitem{langr2013}
LANGR, Jeff; KARWIN, Bill; GRENNING, James W. \textbf{Modern C++ Programming with Test-Driven Development: Code Better, Sleep Better}. Raleigh: The Pragmatic Bookshelf, 2013. 360 p.

\bibitem{meszaros2007}
MESZAROS, Gerard. \textbf{xUnit Test Patterns: Refactoring Test Code}. Boston: Addison-Wesley Professional, 2007. 944 p.

\bibitem{percival2017}
PERCIVAL, Harry J. W. \textbf{Test-Driven Development with Python: Obey the Testing Goat: Using Django, Selenium, and JavaScript}. 2. ed. Sebastopol: O'Reilly Media, 2017. 624 p.

\bibitem{significados}
SIGNIFICADOS. \textbf{Dicionário Online de Significados}. Disponível em: \url{https://www.significados.com.br/}. Acesso em: 15 out. 2021.

\bibitem{bitzen}
BITZEN. \textbf{O impacto dos bugs em aplicativos para os usuários}. Disponível em: \url{https://bitzen.tech/pt-br/aplicativos/o-impacto-dos-bugs-em-aplicativos-para-os-usuarios/}. Acesso em: 20 out. 2021.

\bibitem{y2k}
WIKIPÉDIA. \textbf{Problema do ano 2000}. Disponível em: \url{https://pt.wikipedia.org/wiki/Problema_do_ano_2000}. Acesso em: 22 out. 2021.

\bibitem{2038}
WIKIPÉDIA. \textbf{Problema do ano 2038}. Disponível em: \url{https://pt.wikipedia.org/wiki/Problema_do_ano_2038}. Acesso em: 22 out. 2021.

\bibitem{knight2012}
SECURITIES AND EXCHANGE COMMISSION. \textbf{In the Matter of Knight Capital Americas LLC}. Administrative Proceeding File No. 3-15570. Washington, DC, 2013. Disponível em: \url{https://www.sec.gov/litigation/admin/2013/34-70694.pdf}. Acesso em: 10 nov. 2024.

\bibitem{citibank2020}
GANDEL, Stephen. \textbf{Citibank just got a \$500 million lesson in the importance of UI design}. Fortune, 2021. Disponível em: \url{https://fortune.com/2021/02/17/citibank-500-million-revlon-loan-ui-error/}. Acesso em: 10 nov. 2024.

\end{thebibliography}

\end{document}